<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客学习记录</title>
    <url>/archives/672c3b43.html</url>
    <content><![CDATA[<p>本博客使用hexo+next搭建，基于Github Page，域名解析使用腾讯云。在搭建过程中遇到了一些小小的问题，在此记录解决方法。</p>
<span id="more"></span>

<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><h3 id="npm换源"><a href="#npm换源" class="headerlink" title="npm换源"></a>npm换源</h3><p>推荐使用换源工具<code>nrm</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g nrm   </span><br></pre></td></tr></table></figure>
<p>查看源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure>
<p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/post/Snipaste_2021-06-06_00-05-20.png" alt="源列表"><br>添加源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm add 源的名称  https:&#x2F;&#x2F; 地址</span><br></pre></td></tr></table></figure>
<p>删除源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm del 源的名字</span><br></pre></td></tr></table></figure>
<p>切换源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm use 源的名字</span><br></pre></td></tr></table></figure>
<p>测试源速度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm test</span><br></pre></td></tr></table></figure>

<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2>]]></content>
      <categories>
        <category>个人博客</category>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>无人机群网络管理系统设计与实现</title>
    <url>/archives/5ba81285.html</url>
    <content><![CDATA[<h2 id="关于这个项目"><a href="#关于这个项目" class="headerlink" title="关于这个项目"></a>关于这个项目</h2><p>此项目为我本科阶段的毕业设计，主要内容是设计实现了一个无人机群网络管理系统，可以监控集群内各无人机的网络连接状态，观察无人机飞行参数，调整各无人机的网络设置信息。</p>
<span id="more"></span>

<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>本设计立足于解决无人机群应用时对于内部网络连接状态的监控，并可以实现实时监视无人机位置和姿态，同时还可以对单个无人机的网络信息进行设置。<br>本文开篇先介绍了关于无人机管理系统以及无人机网络的国内外研究现状，分析了相关发展趋势。然后简单介绍了无人机群网络管理系统开发时所涉及的相关技术和开发环境，本设计主要基于<code>WPF</code>（Windows 呈现基础），包括用于界面设计的<code>XAML </code>语言，用于实现后台逻辑的<code>C# </code>语言。数据库存储使用了<code>SQLite</code>。<br>文章的重点在于各个功能的设计实现上，主要包括：通过<code>GMap.NET</code> 技术加载电子地图，展现无人机群内各无人机的实时位置，进一步实现了无人机历史飞行轨迹绘制；通过在<code>WPF</code> 的<code>Canvas</code> 绘制二次贝塞尔曲线展示集群内无人机之间的网络拓扑；通过<code>Material Design In XAML </code>控件库，使得无人机网络设置信息展示更加美观，当用户更改设置后，信息将借由<code>Socket</code> 类发送给后台服务器以更新无人机设置；无人机飞行姿态的展示是通过虚拟仪表盘实现的，虚拟仪表盘展示了无人机的偏航角、俯仰角、滚动角和海拔；无人机历史飞行轨迹和姿态的展示，调用了数据库内存储的历史飞行信息，同时展示电子地图上的轨迹和实时姿态。<br>最后，通过对系统各模块的单独测试和系统整体调试，验证了系统设计的可行性和可靠性，满足了系统设计的需求，实现了预期效果。</p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/imbois/Design-and-Implementation-of-UAV-Group-Network-Management-System">Design-and-Implementation-of-UAV-Group-Network-Management-System</a></p>
<p>项目地址内<code>Code</code>文件夹是相关代码，<code>Paper</code>文件夹下是项目完成论文。</p>
<blockquote>
<p>这是我第一次自己动手写项目，虽然很简单，很粗糙，不过在完成项目的过程中还是学到很多。感谢很多博客作者和开源项目作者，本项目的完成很大程度上借鉴了他们的成果，写项目的时候忘记统计参考链接了，故未展现相关的链接。</p>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title>王道数据结构练习题代码</title>
    <url>/archives/435383c0.html</url>
    <content><![CDATA[<blockquote>
<p>本文记录王道数据结构每小节练习题中的代码</p>
</blockquote>
<span id="more"></span>

<h2 id="Ch2"><a href="#Ch2" class="headerlink" title="Ch2"></a>Ch2</h2><h3 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h3><p><em><strong>No.1</strong></em><br><strong>问题</strong>：从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值，空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。<br><strong>解答</strong>：<br>算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Del_Min(SqList &amp;L, ElemType &amp;value) &#123;</span><br><span class="line">  &#x2F;&#x2F;删除顺序表L中最小值元素结点，并通过引用型参数value返回其值</span><br><span class="line">  &#x2F;&#x2F;若删除成功，则返回true；否则返回false</span><br><span class="line">  if(L.length &#x3D;&#x3D; 0)</span><br><span class="line">    return false;                               &#x2F;&#x2F;表空，中止操作返回</span><br><span class="line">  value &#x3D; L.data[0];</span><br><span class="line">  int pos &#x3D; 0;                                  &#x2F;&#x2F;假定0号元素的值最小</span><br><span class="line">  for(int i &#x3D; 1; i &lt; L.length; i++)             &#x2F;&#x2F;循环，寻找具有最小值的元素</span><br><span class="line">    if(L.data[i] &lt; value) &#123;                     &#x2F;&#x2F;让value记忆当前具有最小值的元素</span><br><span class="line">      value &#x3D; L.data[i];</span><br><span class="line">      pos &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">  L.data[pos] &#x3D; L.data[L.length-1];             &#x2F;&#x2F;空出的位置由最后一个元素填补</span><br><span class="line">  L.length--;</span><br><span class="line">  return true;                                  &#x2F;&#x2F;此时，value即为最小值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：本题也可用函数返回值返回，两者的区别是：函数返回值只能返回一个值，而参数返回（引用传参）可以返回多个值。<br><em><strong>No.2</strong></em><br><strong>问题</strong>：设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。<br><strong>解答</strong>：<br>算法思想：扫描顺序表L的前半部分元素，对于元素L.data[i]（0 &lt;= i &lt; L.length/2），将其与后半部分的对应元素L.data[L.length-i-1]进行交换。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Reverse(SqList &amp;L) &#123;</span><br><span class="line">  ElemType temp;                    &#x2F;&#x2F;辅助变量</span><br><span class="line">  for(int i &#x3D; 0; i &lt; L.length&#x2F;2; i++) &#123;</span><br><span class="line">    temp &#x3D; L.data[i];               &#x2F;&#x2F;交换L.data[i]与L.data[L.length-i-1]</span><br><span class="line">    L.data[i] &#x3D; L.data[L.length-i-1];</span><br><span class="line">    L.data[L.length-i-1] &#x3D; temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>No.3</strong></em><br><strong>问题</strong>：对长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。<br><strong>解答</strong>：<br>解法一：用k记录顺序表L中不等于x的元素个数（即需要保存的元素个数），边扫描L边统计k，并将不等于x的元素向前移动k个位置，最后修改L的长度。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void del_x_1(SqList &amp;L, ElemType x) &#123;</span><br><span class="line">  &#x2F;&#x2F;本算法实现删除顺序表L中所有值为x的数据元素</span><br><span class="line">  int k &#x3D; 0;                          &#x2F;&#x2F;记录值不等于x的元素个数</span><br><span class="line">  for(int i &#x3D; 0; i &lt; L.length; i++)</span><br><span class="line">    if(L.data[i] !&#x3D; x) &#123;</span><br><span class="line">      L.data[k] &#x3D; L.data[i];</span><br><span class="line">      k++;                            &#x2F;&#x2F;不等于x的元素增1</span><br><span class="line">    &#125;</span><br><span class="line">  L.length &#x3D; k;                       &#x2F;&#x2F;顺序表L的长度等于k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：用k记录顺序表L中等于x的元素个数，边扫描L边统计k，并将不等于x的元素迁移k个位置，最后修改L的长度。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void del_x_2(SqList &amp;L, ElemType x) &#123;</span><br><span class="line">  int k &#x3D; 0, i &#x3D; 0;                     &#x2F;&#x2F;k记录值等于x的元素个数</span><br><span class="line">  while(i &lt; L.length) &#123;</span><br><span class="line">    if(L.data[i] &#x3D;&#x3D; x)</span><br><span class="line">      k++;</span><br><span class="line">    else</span><br><span class="line">      L.data[i-k] &#x3D; L.data[i];          &#x2F;&#x2F;当前元素前移k个位置</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  L.length &#x3D; L.length - k;              &#x2F;&#x2F;顺序表L的长度递减</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，本题还可以考虑设头、尾两个指针（i = 1, j = n），从两端向中间移动，在遇到最左端值x的元素时，直接将最右端值非x的元素左移至值为x的数据元素位置，直到两指针相遇。但这种方法会改变原表中元素的相对位置。<br><em><strong>No.4</strong></em><br><strong>问题</strong>：从顺序表中删除其值在给定值s与t之间（包含s和t，要求s &lt; t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。<br><strong>解答</strong>：<br>算法思想：从前向后扫描顺序表L，用k记录下元素值在s到t之间元素的个数（初始时k=0）。对于当前扫描的元素，若其值不在s到t之间，则前移k个位置；否则执行k++。由于这样每个不在s到t之间的元素仅移动一次，因此算法效率高。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Del_s_t(SqList &amp;L, ElemType s, ElemType t) &#123;</span><br><span class="line">  &#x2F;&#x2F;删除顺序表L中值在给定值s与t（要求s &lt; t）之间的所有元素</span><br><span class="line">  int i, k &#x3D; 0;</span><br><span class="line">  if(L.length &#x3D;&#x3D; 0 || s &gt;&#x3D; t)</span><br><span class="line">    return false;                       &#x2F;&#x2F;线性表为空或s、t不合法，返回</span><br><span class="line">  for(i &#x3D; 0; i &lt; L.length; i++) &#123;</span><br><span class="line">    if(L.data[i] &gt;&#x3D; s &amp;&amp; L.data[i] &lt;&#x3D; t)</span><br><span class="line">      k++;</span><br><span class="line">    else</span><br><span class="line">      L.data[i-k] &#x3D; L.data[i];          &#x2F;&#x2F;当前元素前移k个位置</span><br><span class="line">  &#125;   &#x2F;&#x2F;for</span><br><span class="line">  L.length -&#x3D; k;                        &#x2F;&#x2F;长度减小</span><br><span class="line">  return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：本题也可从后向前扫描顺序表，每遇到一个值在s到t之间的元素，则删除该元素，其后的所有元素全部前移。但移动次数远大于前者，效率不够高。<br><em><strong>No.5</strong></em><br><strong>问题</strong>：从有序顺序表中删除其值在给定值s与t之间（要求s &lt; t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。<br><strong>解答</strong>：<br><strong>注意</strong>：本题与上一题存在区别。因为是有序表，所以删除的元素必然是相连的整体。<br>算法思想：先寻找值大于等于s的第一个元素（第一个删除的元素），然后寻找值大于t的第一个元素（最后一个删除的元素的下一个元素），要将这段元素删除，只需直接将后面的元素前移。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Del_s_t2(SqList &amp;L, ElemType s, ElemType t) &#123;</span><br><span class="line">  &#x2F;&#x2F;删除有序顺序表L中值在给定值s与t之间的所有元素</span><br><span class="line">  int i, j;</span><br><span class="line">  if(s &gt;&#x3D; t || L.length &#x3D;&#x3D; 0)</span><br><span class="line">    return false;</span><br><span class="line">  for(i &#x3D; 0; i &lt; L.length &amp;&amp; L.data[i] &lt; s; i++);     &#x2F;&#x2F;寻找值大于等于s的第一个元素</span><br><span class="line">  if(i &gt;&#x3D; L.length)</span><br><span class="line">    return false;                                     &#x2F;&#x2F;所有元素值均小于s，返回</span><br><span class="line">  for(j &#x3D; i; j &lt; L.length &amp;&amp; L.data[j] &lt;&#x3D; t; j++);    &#x2F;&#x2F;寻找值大于t的第一个元素</span><br><span class="line">  for(; j &lt; L.length; i++, j++)                       &#x2F;&#x2F;前移，填补被删元素位置</span><br><span class="line">    L.data[i] &#x3D; L.data[j];</span><br><span class="line">  L.length &#x3D; i;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>No.6</strong></em><br><strong>问题</strong>：从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。<br><strong>解答</strong>：<br>算法思想：注意是有序顺序表，值相同的元素一定在连续的位置上，用类似于直接插入排序的思想，初始时将第一个元素视为非重复的有序表。之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同，则继续向后判断，若不同，则插入前面的非重复有序表的最后，直至判断到表尾为止。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Delete_Same(SqList &amp;L) &#123;</span><br><span class="line">  if(L.length &#x3D;&#x3D; 0)</span><br><span class="line">    return false;</span><br><span class="line">  int i, j;                               &#x2F;&#x2F;i存储第一个不相同的元素，j为工作指针</span><br><span class="line">  for(i &#x3D; 0, j &#x3D; 1; j &lt; L.length; j++)</span><br><span class="line">    if(L.data[i] !&#x3D; L.data[j])            &#x2F;&#x2F;查找下一个与上个元素值不同的元素</span><br><span class="line">      L.data[++i] &#x3D; L.data[j];            &#x2F;&#x2F;找到后，将元素前移</span><br><span class="line">  L.length &#x3D; i + 1;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>No.7</strong></em><br><strong>问题</strong>：将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。<br><strong>解答</strong>：<br>算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看哪个表还有剩余，将剩下的部分加到新的顺序表后面。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Merge(SqList A, SqList B, SqList &amp;C) &#123;</span><br><span class="line">  &#x2F;&#x2F;将有序顺序表A和B合并为一个新的有序顺序表C</span><br><span class="line">  if(A.length + B.length &gt; C.MaxSize)         &#x2F;&#x2F;大于顺序表的最大长度</span><br><span class="line">    return false;</span><br><span class="line">  int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">  while(i &lt; A.length &amp;&amp; j &lt; B.length) &#123;       &#x2F;&#x2F;循环，两两比较，小者存入结果表</span><br><span class="line">    if(A.data[i] &lt;&#x3D; B.data[j])</span><br><span class="line">      C.data[k++] &#x3D; A.data[i++];</span><br><span class="line">    else</span><br><span class="line">      C.data[k++] &#x3D; B.data[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  while(i &lt; A.length)                         &#x2F;&#x2F;还剩一个没有比较完的顺序表</span><br><span class="line">    C.data[k++] &#x3D; A.data[i++];</span><br><span class="line">  while(j &lt; B.length)</span><br><span class="line">    C.data[k++] &#x3D; B.data[j++];</span><br><span class="line">  C.length &#x3D; k;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>No.8</strong></em><br><strong>问题</strong>：已知在一维数组A[m+n]中依次存放两个线性表（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>m</sub>）和（b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,…,b<sub>n</sub>）。试编写一个函数，将数组中两个顺序表的位置互换，即将（b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,…,b<sub>n</sub>）放在（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>m</sub>）的前面。<br><strong>解答</strong>：<br>算法思想：先将数组A[m+n]中的全部元素（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>m</sub>,b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,…,b<sub>n</sub>）原地逆置为（b<sub>n</sub>,b<sub>n-1</sub>,b<sub>n-2</sub>,…,b<sub>1</sub>,a<sub>m</sub>,a<sub>m-1</sub>,a<sub>m-2</sub>,…,a<sub>1</sub>），再对前n个元素和后m个元素分别使用逆置算法，即可得到（b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,…,b<sub>n</sub>,a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>m</sub>），从而实现顺序表的位置互换。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int DataType;</span><br><span class="line">void Reverse(DataType A[], int left, int right, int arraySize) &#123;</span><br><span class="line">  &#x2F;&#x2F;逆转(aleft, aleft+1, aleft+2,..., aright)为(aright, aright-1,..., aleft)</span><br><span class="line">  if(left &gt;&#x3D; right || right &gt;&#x3D; arraySize)</span><br><span class="line">    return;</span><br><span class="line">  int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">  for(int i &#x3D; 0; i &lt;&#x3D; mid - left; i++) &#123;</span><br><span class="line">    DataType temp &#x3D; A[left+i];</span><br><span class="line">    A[left+i] &#x3D; A[right-i];</span><br><span class="line">    A[right-i] &#x3D; temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Exchange(DataType A[], int m, int n, int arraySize) &#123;</span><br><span class="line">  &#x2F;*数组A[m+n]中，从0到m-1存放顺序表(a1,a2,a3,...,am)，从m到m+n-1存放顺序表(b1,b2,b3,...,bn)，算法将这两个表的位置互换*&#x2F;</span><br><span class="line">  Reverse(A, 0, m+n-1, arraySize);</span><br><span class="line">  Reverse(A, 0, n-1, arraySize);</span><br><span class="line">  Reverse(A, n, m+n-1, arraySize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>No.9</strong></em><br><strong>问题</strong>：线性表（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>）中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置相交换，若找不到，则将其插入表中并使表中元素仍递增有序。<br><strong>解答</strong>：<br>算法思想：顺序存储的线性表递增有序，可以顺序查找，也可以折半查找。题目要求“用最少的时间在表中查找数值为x的元素”，这里应使用折半查找法。<br>本题代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SearchExchangeInsert(ElemType A[], ElemType x) &#123;</span><br><span class="line">  int low &#x3D; 0, high &#x3D; n-1, mid;               &#x2F;&#x2F;low和high指向顺序表下界和上界的下标</span><br><span class="line">  while(low &lt;&#x3D; high) &#123;</span><br><span class="line">    mid &#x3D; (low + high) &#x2F; 2;                   &#x2F;&#x2F;找中间位置</span><br><span class="line">    if(A[mid] &#x3D;&#x3D; x) break;                    &#x2F;&#x2F;找到x，退出while循环</span><br><span class="line">    else if(A[mix] &lt; x) low &#x3D; mid + 1;        &#x2F;&#x2F;到中点mid的右半部去查</span><br><span class="line">    else high &#x3D; mid - 1;                      &#x2F;&#x2F;到中点mid的左半部去查</span><br><span class="line">  &#125;             &#x2F;&#x2F;下面两个if语句只会执行一个</span><br><span class="line">  if(A[mid] &#x3D;&#x3D; x &amp;&amp; mid !&#x3D; n-1) &#123;     &#x2F;&#x2F;若最后一个元素与x相等，则不存在与其后继交换的操作</span><br><span class="line">    t &#x3D; A[mid];</span><br><span class="line">    A[mid] &#x3D; A[mid+1];</span><br><span class="line">    A[mid+1] &#x3D; t;</span><br><span class="line">  &#125;</span><br><span class="line">  if(low &gt; high) &#123;                              &#x2F;&#x2F;查找失败，插入数据元素x</span><br><span class="line">    for(i &#x3D; n-1; i &gt; high; i--) A[i+1] &#x3D; A[i];  &#x2F;&#x2F;后移元素</span><br><span class="line">    A[i+1] &#x3D; x;                                 &#x2F;&#x2F;插入x</span><br><span class="line">  &#125;                                             &#x2F;&#x2F;结束插入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题的算法也可写成三个函数：查找函数、交换后继函数与插入函数。写成三个函数的优点是逻辑清晰、易读。<br><em><strong>No.10</strong></em><br><strong>问题</strong>：设将n(n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0 &lt; p &lt; n)个位置，即将R中的数据由(X<sub>0</sub>,X<sub>1</sub>,…,X<sub>n-1</sub>)变换为(X<sub>p</sub>,X<sub>p+1</sub>,…,X<sub>n-1</sub>,X<sub>0</sub>,X<sub>1</sub>,…,X<sub>p-1</sub>)。要求：<br>1）给出算法的基本设计思想。<br>2）根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。<br>3）说明你所设计算法的时间复杂度和空间复杂度。<br><strong>解答</strong>：<br>1）算法的基本设计思想：可将这个问题视为把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个元素），先将a逆置得到a<sup>-1</sup>b，再将b逆置得到a<sup>-1</sup>b<sup>-1</sup>，最后将整个a<sup>-1</sup>b<sup>-1</sup>逆置得到(a<sup>-1</sup>b<sup>-1</sup>)<sup>-1</sup> = ba。设Reverse函数执行将数组元素逆置的操作，对abcdefgh向左循环移动3（p=3）个位置的过程如下：<br>Reverse(0, p-1)得到cbadefgh；<br>Reverse(p, n-1)得到cbahgfed；<br>Reverse(0, n-1)得到defghabc；<br>注：Reverse中，两个参数分别表示数组中待转换元素的始末位置。<br>2）使用C语言描述算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Reverse(int R[], int from, int to) &#123;</span><br><span class="line">  int i, temp;</span><br><span class="line">  for(i &#x3D; 0; i &lt; (to-from+1)&#x2F;2; i++) &#123;</span><br><span class="line">    temp &#x3D; R[from+i];</span><br><span class="line">    R[from+i] &#x3D; R[to-i];</span><br><span class="line">    R[to-i] &#x3D; temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; &#x2F;&#x2F;Reverse</span><br><span class="line">void Converse(int R[], int n, int p) &#123;</span><br><span class="line">  Reverse(R, 0, p-1);</span><br><span class="line">  Reverse(R, p, n-1);</span><br><span class="line">  Reverse(R, 0, n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）上述算法中三个Reverse函数的时间复杂度分别为O(p/2)、O((n-p)/2)和O(n/2)，故所设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。</p>
<p><em>另解</em>，借助辅助数组来实现。算法思想：创建大小为p的辅助数组S，将R中前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的后续单元。时间复杂度为O(n)，空间复杂度为O(p)。<br><em><strong>No.11</strong></em><br><strong>问题</strong>：一个长度为L(L &gt;= 1)的升序序列S，处在第 L/2(向上取整) 个位置的数称为S的中位数。例如，若序列S<sub>1</sub> = (11, 13, 15, 17, 19)，则S<sub>1</sub>的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S<sub>2</sub> = (2, 4, 6, 8, 20)，则S<sub>1</sub>和S<sub>2</sub>的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：<br>1）给出算法的基本设计思想。<br>2）根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。<br>3）说明你所设计算法的时间复杂度和空间复杂度。</p>
<p><em><strong>No.12</strong></em><br><strong>问题</strong>：已知一个整数序列A = (a<sub>0</sub>,a<sub>1</sub>,…,a<sub>n-1</sub>)，其中 0 &lt;= a<sub>i</sub> &lt; n (0 &lt;= i &lt; n)。若存在a<sub>p1</sub> = a<sub>p2</sub> = … = a<sub>pm</sub> = x 且 m &gt; n/2 (0 &lt;= p<sub>k</sub> &lt; n , 1 &lt;= k &lt;= m)，</p>
]]></content>
      <categories>
        <category>王道论坛</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>王道数据结构思维拓展</title>
    <url>/archives/58b806b9.html</url>
    <content><![CDATA[<blockquote>
<p>本文记录我在学习王道考研教材《数据结构考研复习指导》时，所遇到的各章思考题。仅供参考。</p>
</blockquote>
<span id="more"></span>

<h3 id="Ch1"><a href="#Ch1" class="headerlink" title="Ch1"></a>Ch1</h3><p><strong>题目</strong><br>求解斐波那契数列<br>$$<br>F(n) = \begin{cases}<br>1,                  &amp; \text{n = 0,1} \\<br>F(n-1) + F(n-2),    &amp; \text{n &gt; 1}<br>\end{cases}<br>$$<br>有两种常用的算法：递归算法和非递归算法。试分别分析两种算法的时间复杂度。（提示：请结合归纳总结中的两种方法进行解答。）</p>
<p><strong>解答：</strong><br>两种常用算法：<br>1.递归算法，时间复杂度为O(2<sup>n</sup>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long Fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    else if (n &#x3D;&#x3D; 1)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return Fibonacci(n - 1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Enter an integer number:&quot; &lt;&lt; endl;</span><br><span class="line">    int N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    cout &lt;&lt; Fibonacci(N) &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.非递归算法，时间复杂度为O(n)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long Fibonacci(int n) &#123;</span><br><span class="line">    if (n &lt;&#x3D; 2)</span><br><span class="line">        return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        long num1 &#x3D; 1;</span><br><span class="line">        long num2 &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 2;i &lt; n - 1;i++) &#123;</span><br><span class="line">            num2 &#x3D; num1 + num2;</span><br><span class="line">            num1 &#x3D; num2 - num1;</span><br><span class="line">        &#125;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Enter an integer number:&quot; &lt;&lt; endl;</span><br><span class="line">    int N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    cout &lt;&lt; Fibonacci(N) &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考博客</strong></p>
<blockquote>
<p><a href="https://www.cnblogs.com/abyss1114/p/7272657.html">斐波那契数列两种算法的时间复杂度</a><br><a href="https://www.cnblogs.com/python27/archive/2011/11/25/2261980.html">3种方法求解斐波那契数列</a><br><a href="https://zhuanlan.zhihu.com/p/56444434">三种时间复杂度算法求解斐波那契数列</a></p>
</blockquote>
<h3 id="Ch2"><a href="#Ch2" class="headerlink" title="Ch2"></a>Ch2</h3>]]></content>
      <categories>
        <category>王道论坛</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>王道数据结构课本代码</title>
    <url>/archives/e63b79ef.html</url>
    <content><![CDATA[<blockquote>
<p>本文记录王道数据结构各章知识点部分的代码</p>
</blockquote>
<span id="more"></span>


<h2 id="Ch2"><a href="#Ch2" class="headerlink" title="Ch2"></a>Ch2</h2><h3 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h3><h4 id="2-1-2-线性表的基本操作"><a href="#2-1-2-线性表的基本操作" class="headerlink" title="2.1.2 线性表的基本操作"></a>2.1.2 线性表的基本操作</h4><p><code>InitList(&amp;L)</code>：初始化表。构造一个空的线性表。<br><code>Length(L)</code>：求表长。返回线性表L的长度，即L中数据元素的个数。<br><code>LocateElem(L,e)</code>：按值查找操作。在表L中查找具有给定关键字值的元素。<br><code>GetElem(L,i)</code>：按位查找操作。获取表L中第i个位置的元素的值。<br><code>ListInsert(&amp;L,i,e)</code>：插入操作。在表L中的第i个位置上插入指定元素e。<br><code>ListDelete(&amp;L,i,&amp;e)</code>：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。<br><code>PrintList(L)</code>：输出操作。按前后顺序输出线性表L的所有元素值。<br><code>Empty(L)</code>：判空操作。若L为空表，则返回true，否则返回false。<br><code>DestroyList(&amp;L)</code>：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p>
<blockquote>
<p>“&amp;”表示C++语言中的引用调用，在C语言中采用指针也可达到同样的效果。</p>
</blockquote>
<h3 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h3><h4 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h4><p>假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为：<br>a.静态分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50              &#x2F;&#x2F;定义线性表的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">  ElemType data[MaxSize];       &#x2F;&#x2F;顺序表的元素</span><br><span class="line">  int length;                   &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SqList;                        &#x2F;&#x2F;顺序表的类型定义</span><br></pre></td></tr></table></figure>
<p>b.动态分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define InitSize 100            &#x2F;&#x2F;表长度的初始定义</span><br><span class="line">typedef struct&#123;     </span><br><span class="line">  ElemType *data;               &#x2F;&#x2F;指示动态分配数组的指针</span><br><span class="line">  int MaxSize,length;           &#x2F;&#x2F;数组的最大容量和当前个数</span><br><span class="line">&#125; SeqList;                      &#x2F;&#x2F;动态分配数组顺序表的类型定义</span><br></pre></td></tr></table></figure>
<p>C的初始动态分配语句为：<br><code>L.data = (ElemType *)malloc(sizeof(ElemType)*InitSize);</code><br>C++的初始动态分配语句为：<br><code>L.data = new ElemType[InitSize];</code></p>
<h4 id="2-2-2-顺序表上基本操作的实现"><a href="#2-2-2-顺序表上基本操作的实现" class="headerlink" title="2.2.2 顺序表上基本操作的实现"></a>2.2.2 顺序表上基本操作的实现</h4><p>(1)插入操作<br>在顺序表L的第i(1&lt;=i&lt;=L.length+1)个位置插入新元素e。平均时间复杂度为O(n)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool ListInsert(SqList &amp;L, int i, ElemType e) &#123;</span><br><span class="line">  if(i &lt; 1 || i &gt; L.length+1)             &#x2F;&#x2F;判断i的范围是否有效</span><br><span class="line">	  return false;</span><br><span class="line">  if(L.length &gt;&#x3D; MaxSize)                 &#x2F;&#x2F;当前存储空间已满，不能插入</span><br><span class="line">	  return false;</span><br><span class="line">  for(int j &#x3D; L.length; j &gt;&#x3D;i; j--)       &#x2F;&#x2F;将第i个元素及之后的元素后移</span><br><span class="line">	  L.data[j] &#x3D; L.data[j-1];</span><br><span class="line">  L.data[i-1] &#x3D; e;                        &#x2F;&#x2F;在位置i处放入e</span><br><span class="line">  L.length++;                             &#x2F;&#x2F;线性表长度加1</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)删除操作<br>删除顺序表L中第i(1&lt;=i&lt;=L.length)个位置的元素，用引用变量e返回。平均时间复杂度为O(n)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L, int i, ElemType &amp;e) &#123;</span><br><span class="line">  if(i &lt; 1 || i &gt; L.length)                 &#x2F;&#x2F;判断i的范围是否有效</span><br><span class="line">    return false;</span><br><span class="line">  e &#x3D; L.data[i-1];                          &#x2F;&#x2F;将被删除的元素赋值给e</span><br><span class="line">  for(int j &#x3D; i; j &lt; L.length; j++)         &#x2F;&#x2F;将第i个位置后的元素前移</span><br><span class="line">    L.data[j-1] &#x3D; L.data[j];</span><br><span class="line">  L.length--;                               &#x2F;&#x2F;线性表长度减1</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)按值查找(顺序查找)<br>在顺序表L中查找第一个元素值等于e的元素，并返回其位序。平均时间复杂度为O(n)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int LocateElem(SqList L, ElemType e) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  for(i &#x3D; 0; i &lt; L.length; i++)</span><br><span class="line">    if(L.data[i] &#x3D;&#x3D; e)</span><br><span class="line">      return i+1;                 &#x2F;&#x2F;下标为i的元素值等于e，返回其位序i+1</span><br><span class="line">  return 0;                       &#x2F;&#x2F;退出循环，说明查找失败。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h3><h4 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h4><p>单链表中结点类型的描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct LNode&#123;     &#x2F;&#x2F;定义单链表结点类型</span><br><span class="line">  ElemType data;          &#x2F;&#x2F;数据域</span><br><span class="line">  struct LNode *next;     &#x2F;&#x2F;指针域</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h4><p><strong>1.采用头插法建立单链表</strong><br>该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。<br>算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkList List_HeadInsert(LinkList &amp;L) &#123;     &#x2F;&#x2F;逆向建立单链表</span><br><span class="line">  LNode *s; int x;</span><br><span class="line">  L &#x3D; (LinkList)malloc(sizeof(LNode));      &#x2F;&#x2F;创建头结点</span><br><span class="line">  L-&gt;next &#x3D;&#x3D; NULL;                          &#x2F;&#x2F;初始为空链表</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;x);                          &#x2F;&#x2F;输入结点的值</span><br><span class="line">  while(x !&#x3D; 9999) &#123;                        &#x2F;&#x2F;输入9999表示结束</span><br><span class="line">    s &#x3D; (LNode*)malloc(sizeof(LNode));      &#x2F;&#x2F;创建新结点</span><br><span class="line">    s-&gt;data &#x3D; x;</span><br><span class="line">    s-&gt;next &#x3D; L-&gt;next;</span><br><span class="line">    L-&gt;next &#x3D; s;                            &#x2F;&#x2F;将新结点插入表中，L为头指针</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个结点插入的时间是O(1)，设单链表长为n，则总时间复杂度为O(n)。<br><strong>2.采用尾插法建立单链表</strong><br>该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。<br>算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkList List_TailInsert(LinkList &amp;L) &#123;   &#x2F;&#x2F;正向建立单链表</span><br><span class="line">  int x;                                  &#x2F;&#x2F;设元素类型为整型</span><br><span class="line">  L &#x3D; (LinkList)malloc(sizeof(LNode));</span><br><span class="line">  LNode *s, *r &#x3D; L;                       &#x2F;&#x2F;r为表尾指针</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;x);                        &#x2F;&#x2F;输入结点的值</span><br><span class="line">  while(x !&#x3D; 9999) &#123;                      &#x2F;&#x2F;输入9999表示结束</span><br><span class="line">    s &#x3D; (LNode *)malloc(sizeof(LNode));</span><br><span class="line">    s-&gt;data &#x3D; x;</span><br><span class="line">    r-&gt;next &#x3D; s;</span><br><span class="line">    r &#x3D; s;                                &#x2F;&#x2F;r指向新的表尾结点</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next &#x3D; NULL;                         &#x2F;&#x2F;尾结点指针置空</span><br><span class="line">  return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为附设了一个指向表尾结点的指针，故时间复杂度和头插法的相同。<br><strong>3.按序号查找结点值</strong><br>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。<br>算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LNode *GetElem(LinkList L, int i) &#123;</span><br><span class="line">  int j &#x3D; 1;                      &#x2F;&#x2F;计数，初始为1</span><br><span class="line">  LNode *p &#x3D; L-&gt;next;             &#x2F;&#x2F;头结点指针赋给p</span><br><span class="line">  if(i &#x3D;&#x3D; 0)</span><br><span class="line">    return L;                     &#x2F;&#x2F;若i等于0，则返回头结点</span><br><span class="line">  if(i &lt; 1)</span><br><span class="line">    return NULL;                  &#x2F;&#x2F;若i无效，则返回NULL</span><br><span class="line">  while(p &amp;&amp; j &lt; i) &#123;             &#x2F;&#x2F;从第1个结点开始找，查找第i个结点</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  return p;                       &#x2F;&#x2F;返回第i个结点的指针，若i大于表长，则返回NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)。<br><strong>4.按值查找表结点</strong><br>从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。<br>算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LNode *LocateElem(LinkList L, ElemType e) &#123;</span><br><span class="line">  LNode *p &#x3D; L-&gt;next;</span><br><span class="line">  while(p !&#x3D; NULL &amp;&amp; p-&gt;data !&#x3D; e)        &#x2F;&#x2F;从第1个结点开始查找data域为e的结点</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">  return p;                               &#x2F;&#x2F;找到后返回该结点指针，否则返回NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)。<br><strong>5.插入结点操作</strong><br>插入结点操作将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。<br>代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; GetElem(L, i-1);            &#x2F;&#x2F;查找插入位置的前驱结点</span><br><span class="line">s-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next &#x3D; s;</span><br></pre></td></tr></table></figure>
<p>本算法主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若在给定的结点后面插入新结点，则时间复杂度仅为O(1)。</p>
<p>可采用另一种方式将前插操作转化为后插操作来实现，设待插入结点为<code>*s</code>，将<code>*s</code>插入到<code>*p</code>的前面。我们仍然将<code>*s</code>插入到<code>*p</code>的后面，然后将<code>p-&gt;data</code>与<code>s-&gt;data</code>交换，这样既满足了逻辑关系，又能使得时间复杂度为O(1)。算法的代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将*s结点插入到*p之前的主要代码片段</span><br><span class="line">s-&gt;next &#x3D; p-&gt;next;              &#x2F;&#x2F;修改指针域，不能颠倒</span><br><span class="line">p-&gt;next &#x3D; s;</span><br><span class="line">temp &#x3D; p-&gt;data;                 &#x2F;&#x2F;交换数据域部分</span><br><span class="line">p-&gt;data &#x3D; s-&gt;data;</span><br><span class="line">s-&gt;data &#x3D; temp;</span><br></pre></td></tr></table></figure>

<p><strong>6.删除结点操作</strong><br>删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。<br>代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; GetElem(L, i-1);                &#x2F;&#x2F;查找删除位置的前驱结点</span><br><span class="line">q &#x3D; p-&gt;next;                        &#x2F;&#x2F;令q指向被删除结点</span><br><span class="line">p-&gt;next &#x3D; q-&gt;next;                  &#x2F;&#x2F;将*q结点从链中“断开”</span><br><span class="line">free(q);                            &#x2F;&#x2F;释放结点的存储空间</span><br></pre></td></tr></table></figure>
<p>和插入算法一样，该算法的主要时间夜耗费在查找操作上，时间复杂度为O(n)。</p>
<p>其实，删除结点<code>*p</code>的操作可用删除<code>*p</code>的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。<br>实现上述操作的代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q &#x3D; p-&gt;next;                      &#x2F;&#x2F;令q指向*p的后继结点</span><br><span class="line">p-&gt;data &#x3D; p-&gt;next-&gt;data;          &#x2F;&#x2F;和后继结点交换数据域</span><br><span class="line">p-&gt;next &#x3D; q-&gt;next;                &#x2F;&#x2F;将*q结点从链中“断开”</span><br><span class="line">free(q);                          &#x2F;&#x2F;释放后继结点的存储空间</span><br></pre></td></tr></table></figure>
<p><strong>7.求表长操作</strong><br>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，知道访问到空结点为止。算法的时间复杂度为O(n)。</p>
<h4 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h4><p>双链表中结点类型的描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct DNode&#123;                 &#x2F;&#x2F;定义双链表结点类型</span><br><span class="line">  ElemType data;                      &#x2F;&#x2F;数据域</span><br><span class="line">  struct DNode *prior, *next;         &#x2F;&#x2F;前驱和后继指针</span><br><span class="line">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure>
<p>插入、删除操作的时间复杂度仅为O(1)。<br>插入操作的代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s-&gt;next &#x3D; p-&gt;next;                  &#x2F;&#x2F;将结点*s插入到结点*p之后</span><br><span class="line">p-&gt;next-&gt;prior &#x3D; s;</span><br><span class="line">s-&gt;prior &#x3D; p;</span><br><span class="line">p-&gt;next &#x3D; s;</span><br></pre></td></tr></table></figure>
<p>删除操作的代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;next &#x3D; q-&gt;next;                  &#x2F;&#x2F;删除*p后的*q</span><br><span class="line">q-&gt;next-&gt;prior &#x3D; p;</span><br><span class="line">free(q);                            &#x2F;&#x2F;释放结点空间</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-静态链表"><a href="#2-3-5-静态链表" class="headerlink" title="2.3.5 静态链表"></a>2.3.5 静态链表</h4><p>静态链表结构类型的描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50                    &#x2F;&#x2F;静态链表的最大长度</span><br><span class="line">typedef struct&#123;                       &#x2F;&#x2F;静态链表结构类型的定义</span><br><span class="line">  ElemType data;                      &#x2F;&#x2F;存储数据元素</span><br><span class="line">  int next;                           &#x2F;&#x2F;下一个元素的数组下标</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>王道论坛</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>观影日志</title>
    <url>/archives/cf3bca3b.html</url>
    <content><![CDATA[<p>截至今天，博客已记录电影11部，电视剧1部。</p>
<span id="more"></span>

<h2 id="2021年6月"><a href="#2021年6月" class="headerlink" title="2021年6月"></a>2021年6月</h2><div class="note success">
            <h3 id="6月1日-冰雪奇缘"><a href="#6月1日-冰雪奇缘" class="headerlink" title="6月1日 冰雪奇缘"></a>6月1日 冰雪奇缘</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/4202982.png" alt="冰雪奇缘"><br>艾莎真的太美了。前面一直以为爱情才是治愈冰冻的办法，看到后面才知道爱还有更多含义，其中就包含亲情。爱有治愈一切的力量，它可以让我们变强大，让我们学着控制自己的能力。很喜欢歌曲《Let It Go》。</p>
          </div>

<div class="note success">
            <h3 id="6月7日-真爱至上"><a href="#6月7日-真爱至上" class="headerlink" title="6月7日 真爱至上"></a>6月7日 真爱至上</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/1292401.png" alt="真爱至上"><br>每年圣诞节都会自己去重温的电影，温暖又治愈。影片中的人都经历着不同的爱，有亲情、爱情、友情，有婚姻和暗恋。其实我们的生活又何尝不是，生活中到处都是爱，都是爱着我们的人和我们爱的人。珍惜身边的人，拥抱爱。</p>
          </div>

<div class="note success">
            <h3 id="6月8日-情书"><a href="#6月8日-情书" class="headerlink" title="6月8日 情书"></a>6月8日 情书</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/1292220.png" alt="情书"><br>少年时代单纯的爱情真的太美好了，少年和少女藤井树那种对彼此的感情纯洁而且美丽。成年后的渡边博子对爱人离世的悲伤也随着她和藤井树小姐的信件渐渐消解，终于在呼唤中告别了曾经。</p>
          </div>

<div class="note success">
            <h3 id="6月9日-哈利波特与魔法石"><a href="#6月9日-哈利波特与魔法石" class="headerlink" title="6月9日 哈利波特与魔法石"></a>6月9日 哈利波特与魔法石</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/1295038.png" alt="哈利波特与魔法石"><br>哈利波特真的是我的童年啊，小时候在电影频道看。哈利、罗恩和赫敏三人的友谊非常珍贵。魔法石是哈利波特系列的第一部，介绍了哈利的家世和他与伏地魔的第一次交手，主演们这个时候都好年轻啊。再刷发现海德薇好可爱。以后有机会的话，要去取景地看看，要买周边留着收藏。这一系列电影也是我会多次重刷的。</p>
          </div>


<div class="note success">
            <h3 id="6月10日-爱在黎明破晓前"><a href="#6月10日-爱在黎明破晓前" class="headerlink" title="6月10日 爱在黎明破晓前"></a>6月10日 爱在黎明破晓前</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/1296339.png" alt="爱在黎明破晓前"><br>这部电影其实是爱在三部曲中的第一部，三部电影跨度十几年，男女主人公也在这个过程中慢慢变老，对爱情的态度也在慢慢变化。<br>很感人的一段就是在试音房两个人眼神交替关注着对方，那种心中的萌动真的太美好了。火车上的搭讪也是经典，何不去尝试，这样以后便不会后悔。</p>
          </div>

<div class="note success">
            <h3 id="6月14日-机智医生生活"><a href="#6月14日-机智医生生活" class="headerlink" title="6月14日 机智医生生活"></a>6月14日 机智医生生活</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/33464863.png" alt="机智医生生活"><br>这五个人的友情真的太好了，很感动这种亲密好友之间的友谊。所幸我的人生中也有这种友谊。前几年第一次看请回答1988的时候，也被里面的友谊打动。现在看来，那是少年时期的美好，机智医生里面的友谊是成年人的友谊，多了很多成熟和生活。第一次看这部剧是在20年居家隔离的时候，那时候就深深入迷，比较遗憾的事情是自己没有去学医学，去治病救人。错过了两次学医的机会，一次高考，一次保研。错过就错过吧，往事已不可追悔，就这样去努力吧，去好好生活，珍惜身边的朋友，身边的一切美好。爱生活，爱自己，爱朋友。</p>
          </div>

<div class="note success">
            <h3 id="6月18日-崖上的波妞"><a href="#6月18日-崖上的波妞" class="headerlink" title="6月18日 崖上的波妞"></a>6月18日 崖上的波妞</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/1959877.png" alt="崖上的波妞"><br>小孩子之间的感情真好啊。波妞好可爱。看完电影，印象最深的，就是那句：波妞喜欢宗介。电影想表达的，大概是：爱情无关乎年龄也无关乎外在，爱是值得抛弃一切去付出的美好东西。细思极恐的一点是，如果宗介不再爱波妞，她就会变成泡沫，可能爱情就是这样，对的人收获喜悦，爱错人就会受伤。</p>
          </div>

<div class="note success">
            <h3 id="6月19日-谍影重重"><a href="#6月19日-谍影重重" class="headerlink" title="6月19日 谍影重重"></a>6月19日 谍影重重</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/1304102.png" alt="谍影重重"><br>谍影重重系列是我最喜欢的间谍系列电影了，007和碟中谍其实我都不太来电。这个系列最开始接触时童年时期看电影频道，小时候喜欢幻想自己以后也会过上这种惊险刺激的生活。马特达蒙好帅，重刷的时候发现饰演伯恩同事的那个妹子好好看。后面争取把其余的补全。</p>
          </div>

<div class="note success">
            <h3 id="6月20日-王牌特工：特工学院"><a href="#6月20日-王牌特工：特工学院" class="headerlink" title="6月20日 王牌特工：特工学院"></a>6月20日 王牌特工：特工学院</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/24405378.png" alt="特工学院"><br>之前是从爱奇艺看的，有删减。今天又找了一下资源，看来删掉的部分，也挺有意思。这部电影当个喜剧看还是不错的，科技感十足，但是不能深究其科学原理。比较打动我的是那种英式绅士风度，希望自己以后也会成为有涵养，有礼节的人。ps:瘦下来有钱以后一定去定制西装。</p>
          </div>

<h2 id="2021年7月"><a href="#2021年7月" class="headerlink" title="2021年7月"></a>2021年7月</h2><div class="note success">
            <h3 id="7月9日-中国医生"><a href="#7月9日-中国医生" class="headerlink" title="7月9日 中国医生"></a>7月9日 中国医生</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/35087699.png" alt="中国医生"><br>怎么说呢，很久之前就期待这个电影了，但是看的时候不算达到自己的期望吧。中规中矩的一部献礼片，没有很多槽点和很多闪光点。作为亲历过那段时间的一个普通人而言，代入感很强。电影在一定程度上美化了当时的现实情况，实际上那段时间真的太苦了，医护工作者苦，老百姓也苦。对于想要了解这段过去的人，我更推荐去看纪录片，电影的改编还是挺多的。</p>
          </div>

<div class="note success">
            <h3 id="7月14日-黑寡妇"><a href="#7月14日-黑寡妇" class="headerlink" title="7月14日 黑寡妇"></a>7月14日 黑寡妇</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/25828589.png" alt="黑寡妇"><br>上周下了以后没字幕，看不下去。今天不想学习，就又翻出来看了一下。感觉没知乎上那么人说的不咋滴啊，我挺喜欢的，可能是因为我是一个假漫威迷。寡姐真的太好看了，又是想拜倒在她面前的一天。是挺有意思的一个商业电影了吧，就是有一点，好像剧情都不能给我留下特别深的印象，没有特别触动的点。感觉两个小时的电影好快，讲了很多事情。还是很推荐的。</p>
          </div>

<div class="note success">
            <h3 id="8月25日-健听女孩"><a href="#8月25日-健听女孩" class="headerlink" title="8月25日 健听女孩"></a>8月25日 健听女孩</h3><p><img src="https://blogimbois-1256390899.cos.ap-beijing.myqcloud.com/movie/35048413.png" alt="健听女孩"><br>第一次看这种展现聋哑人生活的电影，最触动的一段是女儿在音乐会二重唱的时候，片子静默，仿佛我也身处其中，对周围无声的那种无助和茫然非常绝望。看完电影好想学手语啊。影片中的歌曲也很棒。人，总要远行，走出舒适区，不要畏惧失败，勇敢去尝试。男女主好配啊，青涩单纯的样子。</p>
          </div>]]></content>
      <categories>
        <category>生活</category>
        <category>影音</category>
      </categories>
      <tags>
        <tag>影音</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
